ifile = open('mem_input.txt', 'r')
ofile = open('mem_functions.hpp', 'w')

def split_ty(arg):
    if '*' in arg:
        (t,_,n) = arg.rpartition('*')
        return t.strip()+'*', n.strip()
    (t,_,n) = arg.rpartition(' ')
    return t.strip(),n.strip()

ofile.write('// Generated by mem_process.py, do not edit\n\n')
ofile.write('static void _doMemOpPost(bool is_async);\n')
ofile.write('static void _doMemOpPre(bool is_async, CUstream hStream);\n\n')

def_map = ''

for line in ifile:
    line = line.strip()
    if len(line) > 1:
        [pre, post] = line.split('(')
        [rty, ann, name] = pre.split(' ')
        [args, _] = post.split(')')
        # [(type, name)]
        args = list(map(split_ty, args.split(',')))

        # real function pointer
        ofile.write(f'{rty} {ann} (*real_{name}) (')
        ofile.write(', '.join(f'{t} {n}' for (t,n) in args))
        ofile.write(');\n')

        # fake function
        ofile.write(f'{rty} {ann} fake_{name}(')
        ofile.write(', '.join(f'{t} {n}' for (t,n) in args))
        ofile.write(') {\n')
        # logging
        ofile.write(f'  if constexpr (LOG_MEMORY) std::cout << "DRIVER-INJECT-M: {name}" << std::endl;\n');
        # locking
        is_async = 'Async' in name # and 'DtoH' not in name
        # alas, DtoH only self-synchronizes when using pageable memory
        # and there's no reliable way to check if the memory they gave us is pageable
        # we would need it to be conservative, i.e. always tell us it's pinned if it is pinned
        # and there's nothing that does this (all we can do is e.g. check if it was cudaMallocHost()'d)
        if is_async:
            ofile.write('  _doMemOpPre(true, hStream);\n')
        else:
            ofile.write('  _doMemOpPre(false, nullptr);\n')
        # call real function
        ofile.write(f'  {rty} r = real_{name}(');
        ofile.write(', '.join(n for (t,n) in args))
        ofile.write(');\n')
        # locking
        ofile.write(f'  _doMemOpPost({str(is_async).lower()});\n')
        ofile.write('  return r;\n}\n')

        def_map += f'{{ "{name}", {{ (void*) fake_{name}, (void**)&real_{name} }} }},'

ofile.write(f'\n#define MEM_OPS_MAP {def_map}')
